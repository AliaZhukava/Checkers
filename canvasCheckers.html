<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Checkers</title>
    <script>

        //определяем константы
        var SQUARE_SIZE = 60;// описали размер клетки
        var BOARD_WIDTH = SQUARE_SIZE * 8; //ширина доски
        var BOARD_HEIGHT = SQUARE_SIZE * 8;//высота доски
        var BLACK = "#000000"; //цвет черных клеток
        var WHITE = "#F5FFFA";//цвет белых клеток
        var BlackCheck = "#4B0082"; //определяем черные шашки
        var WhiteCheck = "#FF00FF";//определяем белые шашки

        var WHOS_TURN_IS_IT = BlackCheck;//кто ходит - задаем черный

        // Объявляем массивы для отслеживания местоположений фрагментов
        var pieceTracker = new Array(); //массив куда складываем перемещения
        var board;//определяем доску
        var boardContext;//определяем context для canvas
        var pieceBeingMoved;//определяем перемещенные элементы
        var gameInProgress;//определяем состояние игры
        var cursorLocation = [0,0];//определяем массив расположения курсора
        var jumpLocation = [0,0];//определяем массив в который пишем ходы
        var playerOneScore = 0;//задаем счет для первого игрока
        var playerTwoScore = 0;//задаем счет для второго игрока

        function initializeGame()//создаем функцию инициализации игры
        {
            // получаем canvas элементы
            board = document.getElementById("board");//получаем узел нашего canvas (холста)
            boardContext = board.getContext("2d"); //метод getContext для получения контекста визуализации и функции рисования

            // сбрасывем счет
            var scoreCard = document.getElementById("score_card");
            //вставляем кнопку начала игры
            scoreCard.innerHTML = "<div id='restart_game' onclick='restartGame(); return false;'>НАЧНЕМ ИГРАТЬ</div>";
            //вставляем параметры счет первого игрока
            scoreCard.innerHTML += "<div id='player_one' class='player'>Счет первого игрули: <span id='player_one_score'></span></div>";
            //вставляем параметры счет второго игрока
            scoreCard.innerHTML += "<div id='player_two' class='player'>Счет второго игрули: <span id='player_two_score'></span></div>";
            //информируем кто должен сделать ход
            scoreCard.innerHTML += "<div id='whosturn'></div>";

            // проверяем если local storage поддерживается
            if(supportsLocalStorage()) {

                gameInProgress = localStorage["checkers.game.in.progress"];//gameInProgress  в данном случае это значение хранилища localStorage с ключом checkers.game.in.progress
                // проверяем идет ли процесс игры
                if(gameInProgress == "true") {
                    // восстанавливаем сохраненные переменные
                    playerOneScore = parseInt(localStorage["checkers.player.one.score"]);//Функция parseInt преобразует аргумент в число. аргумент здесь это значение хранилища localStorage с ключом checkers.player.one.score
                    playerTwoScore = parseInt(localStorage["checkers.player.two.score"]);//Функция parseInt преобразует аргумент в число. аргумент здесь это значение хранилища localStorage с ключомcheckers.player.two.score
                    pieceTracker = JSON.parse(localStorage["checkers.piece.tracker"]);////спарсим значение обратно в объект
                    WHOS_TURN_IS_IT = localStorage["checkers.whos.turn.is.it"];

                    // отрисовываем сохраненную игру
                    drawGame();
                } else {
                    // начинаем новую игру
                    newGame();
                }
            } else {
                // начинаем новую игру
                newGame();
            }

            // установка футера
            var footer = document.getElementsByTagName("footer")[0];
            footer.innerHTML = "©2017 DreamTeam";
            if(BOARD_HEIGHT > browserHeight()) {
                footer.style.top = BOARD_HEIGHT + 2 + "px";
            } else {
                footer.style.bottom = "0px";
            }
        }

        function newGame()
        {
            // сброс игровых переменных
            WHOS_TURN_IS_IT = WhiteCheck;
            pieceTracker = new Array();
            gameInProgress = true;
            cursorLocation = [0,0];
            jumpLocation = [0,0];
            playerOneScore = 0;
            playerTwoScore = 0;

            //сброс счета
            document.getElementById("player_one_score").innerHTML = playerOneScore;
            document.getElementById("player_two_score").innerHTML = playerTwoScore;

            //учтановка начальных позиций
            initializePieces();

            // отрисовка доски и клеток
            drawGame();

            // сохранение игры
            saveGame();
        }

        function initializePieces()
        {
            // инициализация счетчиков шашек
            var BLACKCounter = 0;
            var WHITECounter = 0;
            var pieceCounter = 0

            for(var j = 1; j < 9; j++) {
                for(var i = 1; i < 9; i+=2) {
                    if(j < 4) {
                        // добавим черные шашки в массив
                        pieceTracker.push(new piece(i + (j % 2),j,false,BlackCheck));
                    } else if(j > 5) {
                        // добавим белые шашки в массив
                        pieceTracker.push(new piece(i + (j % 2),j,false,WhiteCheck));
                    }
                }
            }
        }

        function piece(x,y,k,c)
        {
            // устанавливаем столбцы, строки, дамки и цвет
            this.col = x;
            this.row = y;
            this.king = k;
            this.color = c;
        }

        function drawGame()
        {
            // чистим canvas изменяя размер доски
            board.width = BOARD_WIDTH;
            board.height = BOARD_HEIGHT;

            // изменение позиции доски
            positionBoard();

            // отрисовка клеток
            drawBoard();

            // отрисовка шашек
            drawPieces();

            // меняем идентификатор начала движения
            if(WHOS_TURN_IS_IT == BlackCheck) {
                document.getElementById("whosturn").innerHTML = "ходят ФИОЛЕТОВЕНЬКИЕ";
                document.getElementById("whosturn").style.color = WHOS_TURN_IS_IT;
            } else if(WHOS_TURN_IS_IT == WhiteCheck) {
                document.getElementById("whosturn").innerHTML = "ходят РОЗОВЕНЬКИЕ";
                document.getElementById("whosturn").style.color = WHOS_TURN_IS_IT;
            }

            // обновление счета
            document.getElementById("player_one_score").innerHTML = playerOneScore;
            document.getElementById("player_two_score").innerHTML = playerTwoScore;
        }

        function positionBoard()
        {
            // установка canvas позиции
            if((browserWidth() - BOARD_WIDTH) / 2 > 250) {
                board.style.left = (browserWidth() - BOARD_WIDTH) / 2 + "px";
                document.getElementById("score_card").style.width = board.offsetLeft + "px";
            } else {
                board.style.left = "250px";
                document.getElementById("score_card").style.width = "250px";
            }

            // установка позиции футера
            if((BOARD_WIDTH + board.offsetLeft) > browserWidth()) {
                var footer = document.getElementsByTagName("footer")[0];
                footer.style.width = 250 + BOARD_WIDTH + 2 + "px";
            } else {
                var footer = document.getElementsByTagName("footer")[0];
                if(BOARD_HEIGHT > browserHeight()) {
                    footer.style.width = browserWidth() - 17 + "px";
                } else {
                    footer.style.width = browserWidth() + "px";
                }
            }
        }

        function drawBoard()
        {
            for(var i = 1; i < 9; i++) {
                for(var j = 1; j < 9; j++) {
                    // отрисовываем клетки используя колонки и строки i и j
                    drawSquare(i,j);
                }
            }

            // устанавливем обработчик события на клик по доске
            board.addEventListener("mousedown",clickPiece,false);
        }

        function drawSquare(x,y)
        {
            var color;

            // переключение между черными и белами клетками в зависимости от расположения
            if(((x % 2 == 0) && (y % 2 == 0)) || ((x % 2 == 1) && (y % 2 == 1))) {
                color = BLACK;
            } else if(((x % 2 == 0) && (y % 2 == 1)) || ((x % 2 == 1) && (y % 2 == 0))) {
                color = WHITE;
            }

            // рисуем клетки используя значения колонок и строк, col и row и color
            boardContext.beginPath();
            boardContext.fillStyle = color;
            boardContext.moveTo((x - 1) * SQUARE_SIZE,(y - 1) * SQUARE_SIZE);
            boardContext.lineTo(x * SQUARE_SIZE,(y - 1) * SQUARE_SIZE);
            boardContext.lineTo(x * SQUARE_SIZE,y * SQUARE_SIZE);
            boardContext.lineTo((x - 1) * SQUARE_SIZE,y * SQUARE_SIZE);
            boardContext.lineTo((x - 1) * SQUARE_SIZE,(y - 1) * SQUARE_SIZE);
            boardContext.closePath();
            boardContext.fill();
        }

        function drawPieces()
        {
            // отрисовываем шашки в массив
            for(var i = 0; i < pieceTracker.length; i++) {
                boardContext.beginPath();
                boardContext.fillStyle = pieceTracker[i].color;
                boardContext.lineWidth = 2;
                boardContext.strokeStyle = BlackCheck;
                boardContext.arc((pieceTracker[i].col - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(pieceTracker[i].row - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(SQUARE_SIZE * 0.5) - 10,0,2 * Math.PI,false);
                boardContext.closePath();
                boardContext.stroke();
                boardContext.fill();

                boardContext.beginPath();
                boardContext.lineWidth = 5;
                boardContext.strokeStyle = "#F0F8FF";
                boardContext.arc((pieceTracker[i].col - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(pieceTracker[i].row - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(SQUARE_SIZE * 0.5) - 15,0,2 * Math.PI,false);
                boardContext.closePath();
                boardContext.stroke();
                boardContext.fill();
                // добавляем дамку если достигли нужной части доски
                if(pieceTracker[i].king) {
                    boardContext.beginPath();
                    boardContext.lineWidth = 10;
                    boardContext.strokeStyle = "#ADFF2F";
                    boardContext.arc((pieceTracker[i].col - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(pieceTracker[i].row - 1) * SQUARE_SIZE + (SQUARE_SIZE * 0.5) + 0.5,(SQUARE_SIZE * 0.5) - 20,0,2 * Math.PI,false);
                    boardContext.closePath();
                    boardContext.stroke();
                }
            }
        }

        function canvasLoc(e)
        {
            var canvasLocation = [0,0];
            var canvasXOffset = document.getElementById("board").offsetLeft;
            var canvasYOffset = document.getElementById("board").offsetTop;

            // получаем расположение курсорра относительно браузера
            if ((e.pageX != undefined) && (e.pageY != undefined)) {
                canvasLocation[0] = e.pageX;
                canvasLocation[1] = e.pageY;
            } else {
                canvasLocation[0] = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                canvasLocation[1] = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }

            canvasLocation[0] -= canvasXOffset;
            canvasLocation[1] -= canvasYOffset;

            return canvasLocation;
        }

        function cursorLoc(e)
        {
            var canvasLocation = canvasLoc(e);

            // Получаем расположение курсора относительно квадратов на доске и сохраняем в массиве
            var cl1 = Math.ceil(canvasLocation[0] * (1 / SQUARE_SIZE));
            var cl2 = Math.ceil(canvasLocation[1] * (1 / SQUARE_SIZE));
            cursorLocation = [cl1,cl2];
        }

        function clickPiece(e)
        {
            // Получаем текущее местоположение квадратов
            cursorLoc(e);


            var isPiece = checkForPiece();
            // проверяем если на квадрат кликнули занят ли он и какого цвета
            // если при клике пользователь делает ход продолжаем игру
            if(isPiece == WHOS_TURN_IS_IT) {
                // удаляем шашку из массива чтобы это выглядело как будто мы ее взяли
                for(var i = 0; i < pieceTracker.length; i++) {
                    if((pieceTracker[i].col == cursorLocation[0]) && (pieceTracker[i].row == cursorLocation[1])) {
                        pieceBeingMoved = pieceTracker[i];
                        pieceTracker.splice(i,1);
                    }
                }

                // устанавливаем обработчик события  drag and  drop
                board.addEventListener("mousemove",dragPiece,false);
                board.addEventListener("mouseup",dropPiece,false);
            }
        }

        function checkForPiece()
        {
            // проверяем состояние ли квадрата, есть ли в нем шашка и возвращаем цвет

            var pieceColor = null;
            for(var i = 0; i < pieceTracker.length; i++) {
                if((pieceTracker[i].col == cursorLocation[0]) && (pieceTracker[i].row == cursorLocation[1])) {
                    pieceColor = pieceTracker[i].color;
                }
            }

            return pieceColor;
        }

        function dragPiece(e)
        {
            // получем расположение курсора
            cursorLoc(e);
            drawGame();

            // берем шашку и перерисовываем игру пока не отпустим шашку
            var canvasLocation = canvasLoc(e);
            boardContext.beginPath();
            boardContext.fillStyle = WHOS_TURN_IS_IT;
            boardContext.lineWidth = 2;
            boardContext.strokeStyle = BlackCheck;
            boardContext.arc(canvasLocation[0],canvasLocation[1],(SQUARE_SIZE * 0.5) - 10,0,2 * Math.PI,false);
            boardContext.closePath();
            boardContext.stroke();
            boardContext.fill();

            boardContext.beginPath();
            boardContext.fillStyle = WHOS_TURN_IS_IT;
            boardContext.lineWidth = 5;
            boardContext.strokeStyle = "#F0F8FF";
            boardContext.arc(canvasLocation[0],canvasLocation[1],(SQUARE_SIZE * 0.5) - 15,0,2 * Math.PI,false);
            boardContext.closePath();
            boardContext.stroke();
            boardContext.fill();
            //превращаем шашку в дамку
            if(pieceBeingMoved.king) {
                boardContext.beginPath();
                boardContext.lineWidth = 10;
                boardContext.strokeStyle = "#ADFF2F";
                boardContext.arc(canvasLocation[0],canvasLocation[1],(SQUARE_SIZE * 0.5) - 20,0,2 * Math.PI,false);
                boardContext.closePath();
                boardContext.stroke();
            }
        }

        function dropPiece(e)
        {
            // получаем местонахождение курсора и получаем легальный статус
            cursorLoc(e);
            var checkPiece = checkForPiece();
            var checkDiag = checkDiagonalMove();
            var checkJump = checkJumpOver();
            //проверяем разрешен ли ход
            // если разрешен, двигаем шашку, если нет-возвращаем ее обратно где взяли

            if(!checkPiece && checkDiag && checkJump) {
                // создаем новую шашку и добавляем ее в массив, отслеживающий перемещения
                var newPiece = new piece(cursorLocation[0],cursorLocation[1],checkKingMe(),WHOS_TURN_IS_IT);
                pieceTracker.push(newPiece);
                // если шашка перепрыгивает шашку противника добавляем очко победителю

                if(checkJump == 1) {
                    removePiece();
                }

                // проверяем на победу

                checkForWin();
            } else {
                // если ход запрещен возвращаем шашку обратно
                pieceTracker.push(pieceBeingMoved);
            }

            // сохраняем текущее состояние игры
            saveGame();

            // удаляем обработчики событий и перерисовываем доску
            board.removeEventListener("mousemove",dragPiece,false);
            board.removeEventListener("mouseup",dropPiece,false);
            drawGame();

            // устанавливаем отметку перемещаемой шашки false
            pieceBeingMoved = false;
        }

        function checkDiagonalMove()
        {
            var diagonalMove = true;

            // если шашка стала дамкой применяем другие ограничения

            if(pieceBeingMoved.king) {
                if((cursorLocation[0] == pieceBeingMoved.col) || (cursorLocation[1] == pieceBeingMoved.row) || (Math.abs(pieceBeingMoved.col - cursorLocation[0]) != Math.abs(pieceBeingMoved.row - cursorLocation[1]))) {
                    diagonalMove = false;
                }
            } else {
                if(WHOS_TURN_IS_IT == BlackCheck) {
                    if((cursorLocation[0] == pieceBeingMoved.col) || (cursorLocation[1] <= pieceBeingMoved.row) || (Math.abs(pieceBeingMoved.col - cursorLocation[0]) > 2) || (Math.abs(pieceBeingMoved.col - cursorLocation[0]) != Math.abs(pieceBeingMoved.row - cursorLocation[1]))) {
                        diagonalMove = false;
                    }
                } else {
                    if((cursorLocation[0] == pieceBeingMoved.col) || (cursorLocation[1] >= pieceBeingMoved.row) || (Math.abs(pieceBeingMoved.col - cursorLocation[0]) > 2) || (Math.abs(pieceBeingMoved.col - cursorLocation[0]) != Math.abs(pieceBeingMoved.row - cursorLocation[1]))) {
                        diagonalMove = false;
                    }
                }
            }

            return diagonalMove;
        }

        function checkJumpOver()
        {
            var jumpOver = 0;
            // если шашка стала дамкой применяем другие условия

            if(pieceBeingMoved.king) {
                // получаем столбцы и строки отличные от начальных для шашки при drop позиции
                var colDifference = pieceBeingMoved.col - cursorLocation[0];
                var rowDifference = pieceBeingMoved.row - cursorLocation[1];
                var colTemp = pieceBeingMoved.col;
                var rowTemp = pieceBeingMoved.row;
                var pieceCounter = 0;
                var colorMatch = 0;

                // проверка клеток, которые были перепрыгнуты и наличие шашек противника в них
                for(var i = 0; i < Math.abs(colDifference); i++) {
                    // получение клеток, которые были перепрыгнуты
                    colTemp -= colDifference/Math.abs(colDifference);
                    rowTemp -= rowDifference/Math.abs(rowDifference);

                    // проверка позиций на наличие шашек и определение их цвета

                    for(var j = 0; j < pieceTracker.length; j++) {
                        if((pieceTracker[j].col == colTemp) && (pieceTracker[j].row == rowTemp)) {
                            if(pieceTracker[j].color == pieceBeingMoved.color) {
                                colorMatch++;
                            } else {
                                jumpLocation[0] = pieceTracker[j].col;
                                jumpLocation[1] = pieceTracker[j].row;
                                pieceCounter++;
                            }
                        }
                    }
                }

                // установка значения flag на место куда прыгнула шашка
                if(pieceCounter == 0 && colorMatch == 0) {
                    jumpOver = 2;
                } else if(pieceCounter == 1 && colorMatch == 0) {
                    jumpOver = 1;
                }
            } else {
                if((Math.abs(pieceBeingMoved.col - cursorLocation[0]) == 2 ) && (Math.abs(pieceBeingMoved.row - cursorLocation[1]) == 2)) {
                    // получение значений столбца и строки перепрыгнутой клетки
                    if(pieceBeingMoved.col - cursorLocation[0] > 0) {
                        jumpLocation[0] = pieceBeingMoved.col - 1;
                    } else {
                        jumpLocation[0] = pieceBeingMoved.col + 1;
                    }
                    if(pieceBeingMoved.row - cursorLocation[1] < 0) {
                        jumpLocation[1] = pieceBeingMoved.row + 1;
                    } else {
                        jumpLocation[1] = pieceBeingMoved.row - 1;
                    }

                    // проверка содержит ли клетка шашку и каков ее цвет
                    for(var i = 0; i < pieceTracker.length; i++) {
                        if((pieceTracker[i].col == jumpLocation[0]) && (pieceTracker[i].row == jumpLocation[1]) && (pieceTracker[i].color != pieceBeingMoved.color)) {
                            jumpOver = 1;
                        }
                    }
                } else {
                    jumpOver = 2;
                }
            }

            return jumpOver;
        }

        function removePiece()
        {
            // удаление перемещенной шашки из массива передвижений
            for(var i = 0; i < pieceTracker.length; i++) {
                if((pieceTracker[i].col == jumpLocation[0]) && (pieceTracker[i].row == jumpLocation[1])) {

                    if(pieceTracker[i].color == BlackCheck) {
                        playerTwoScore += 1;
                    } else {
                        playerOneScore += 1;
                    }

                    // удаление шашки
                    pieceTracker.splice(i,1);
                }
            }
        }

        function checkForWin()
        {
            // проверка на победителя
            if((playerOneScore == 12) || (playerTwoScore == 12)) {
                //устанавливаем победителя
                var winner = (playerOneScore == 12) ? "первый игруля" : "второй игруля";

                // удаляем обработчики событий и перерисовываем доску
                board.removeEventListener("mousedown",clickPiece,false);
                board.removeEventListener("mousemove",dragPiece,false);
                board.removeEventListener("mouseup",dropPiece,false);
                drawGame();

                // сбрасываем gameInProgress flag
                gameInProgress = false;

                // обьявляем пользователя победителем и начинаем игру заново
                alert("Победил" + winner + "!");
                newGame();
            } else {
                //  если никто не победил меняем пользователей местами
                if(WHOS_TURN_IS_IT == BlackCheck) {
                    WHOS_TURN_IS_IT = WhiteCheck;
                } else if(WHOS_TURN_IS_IT == WhiteCheck) {
                    WHOS_TURN_IS_IT = BlackCheck;
                }
            }
        }

        function saveGame()
        {
            // проверяем поддерживает ли браузер local storage и сохраняем текущее состояние игры
            if (supportsLocalStorage()) {
                localStorage["checkers.game.in.progress"] = gameInProgress;
                localStorage["checkers.player.one.score"] = playerOneScore;
                localStorage["checkers.player.two.score"] = playerTwoScore;
                localStorage["checkers.piece.tracker"] = JSON.stringify(pieceTracker);
                localStorage["checkers.whos.turn.is.it"] = WHOS_TURN_IS_IT;
            }
        }

        function checkKingMe()
        {
            var kingMe = false;
            // проверяем если черные или белые шашки достигли другоо конца доски или уже являются дамками

            if((pieceBeingMoved.color == BlackCheck) && (cursorLocation[1] == 8)) {
                kingMe = true;
            } else if((pieceBeingMoved.color == WhiteCheck) && (cursorLocation[1] == 1)) {
                kingMe = true;
            } else if(pieceBeingMoved.king) {
                kingMe = true;
            }

            return kingMe;
        }

        function restartGame()
        {
            newGame();

        }

        function supportsLocalStorage() {
            //проверяем поддерживает ли браузер local storage
            var localStorageSupport = (('localStorage' in window) && (window['localStorage'] !== null));
            return localStorageSupport;
        }

        function browserHeight()
        {
            var height;
            // определяем высоту окна браузера

            if (typeof window.innerWidth != 'undefined') {
                height = window.innerHeight;
            } else if (typeof document.documentElement != 'undefined' && typeof document.documentElement.clientWidth != 'undefined' && document.documentElement.clientWidth != 0) {
                height = document.documentElement.clientHeight;
            } else {
                height = document.getElementsByTagName('body')[0].clientHeight;
            }

            return height;
        }

        function browserWidth()
        {
            var width;
            // определяем ширину окна браузера

            if (typeof window.innerWidth != 'undefined') {
                width = window.innerWidth;
            } else if (typeof document.documentElement != 'undefined' && typeof document.documentElement.clientWidth != 'undefined' && document.documentElement.clientWidth != 0) {
                width = document.documentElement.clientWidth;
            } else {
                width = document.getElementsByTagName('body')[0].clientWidth;
            }

            return width;
        }

    </script>

    <style>


        footer {
            background-color:#000000;
            position:absolute;
            left:0px;
            height:25px;
            color: #ddf;
            text-align:center;
            font-weight:bold;
            font-size:18px;
        }

        #board {
            border:1px solid BLACK;
            position:absolute;
            top:0px;
            box-shadow: 0 0 5em .5em rgba(120, 120, 233, 0.774);
        }

        #score_card {
            position:absolute;
            left:0px;
            top:0px;

        }


        .player {
            border:2px solid  #ddf;
            border-radius:10px;
            margin:5px;
            padding:5px;
            text-align:center;
            font-weight:bold;
            font-size:18px;
        }

        #whosturn {
            border:2px solid  #ddf;
            border-radius:10px;
            margin:5px;
            padding:5px;
            text-align:center;
            font-weight:bold;
            font-size:18px;
            text-decoration-color: BLACK;
        }

        #no_html5 {
            color:WHITE;
            font-size:larger;
        }

        html, body{
            margin: 0;
            padding: 0;
            color: #ddf;
            background-color: #112;
            text-align: center;
            padding-top: 20vh;
        }

        #restart_game,
        #restart_game::before,
        #restart_game::after,
        #restart_game span,
        #restart_game span::before,
        #restart_game span::after
        {
            transition: all ease .5s;
        }

        #restart_game{
            position: relative;
            display: inline-block;
            padding: 0.3em;
            margin: 1em;
            box-shadow: 3px 3px 2px #888;
            font-weight:bold;
            font-size:18px;
            border: solid 1px;
            text-transform: uppercase;
            cursor: pointer;
        }

        #restart_game:hover
        {
            box-shadow: 0 0 5em .5em rgba(50,50,150,0.5);
        }

        #restart_game span
        {
            display: inline-block;
            width: 100%;
            padding: 0.6em 2em;
        }

        #restart_game:hover span
        {
            background-color: #ddf;
            color: #112;
        }

        #restart_game::before,
        #restart_game::after,
        #restart_game span::before,
        #restart_game span::after
        {
            content: '';
            position: absolute;
            border: 1px;
        }

        #restart_game::before,
        #restart_game span::before
        {
            border-style: solid none;
        }

        #restart_game::before,
        #restart_game span::after{
            left: 0;
            top: -0.4em;
            width: 100%;
            height: calc(100% + 0.8em);
        }

        #restart_game::after,
        #restart_game span::after
        {
            border-style: none solid;
        }

        #restart_game::after,
        #restart_game span::before
        {
            top: 0;
            left: -0.4em;
            height: 100%;
            width: calc(100% + 0.8em);
        }

        #restart_game:hover::after,
        #restart_game:hover span::after
        {
            transform: scaleY(0);
        }

        #restart_game:hover::before,
        #restart_game:hover span::before
        {
            transform: scaleX(0);
        }

        #restart_game:hover span::after,
        #restart_game:hover span::before
        {
            opacity: 0;
        }

    </style>

</head>

<body onResize="drawGame()">
<canvas id="board">
    <span id="no_html5">Your Browser Does Not Support HTML5's Canvas Feature. Please Try Again Using Either Chrome Or Safari.</span>
</canvas>
<div id="score_card"></div>
<footer></footer>
<script type="text/javascript">
    initializeGame();
</script>


</body>
</html>